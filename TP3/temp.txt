{ // Textures
        // glActiveTexture(GL_TEXTURE0);
        // GLuint grassTexture = loadTexture("grass.png");
        // glBindTexture(GL_TEXTURE_2D,grassTexture);
        // GLuint grassTextureID = glGetUniformLocation(programID,"GRASS");
        // glUniform1i(grassTextureID, 0);
        
        // glActiveTexture(GL_TEXTURE1);
        // GLuint rockTexture = loadTexture("rock.png");
        // glBindTexture(GL_TEXTURE_2D,rockTexture);
        // GLuint rockTextureID = glGetUniformLocation(programID,"ROCK");
        // glUniform1i(rockTextureID, 1);

        // glActiveTexture(GL_TEXTURE2);
        // GLuint snowTexture = loadTexture("snowrocks.png");
        // glBindTexture(GL_TEXTURE_2D,snowTexture);
        // GLuint snowTextureID = glGetUniformLocation(programID,"SNOW");
        // glUniform1i(snowTextureID, 2);

        // glActiveTexture(GL_TEXTURE3);
        // GLuint heightmapTexture = loadTexture("heightmap-1024x1024.png");
        // glBindTexture(GL_TEXTURE_2D,heightmapTexture);
        // GLuint heightmapID = glGetUniformLocation(programID,"heightmap");
        // glUniform1i(heightmapID, 3);

        // GLuint heightScaleID = glGetUniformLocation(programID,"heightScale");
        // glUniform1f(heightScaleID,1.0f);
    }
    
    // std::vector<glm::vec3> plan;
    // std::vector<glm::vec2> uvs;
    // std::vector<unsigned short> indices_plan;

    { // Initialisation du plan
        // float taille = 10.0f;
        // float m = taille / 2.0f;
        // float pas = taille / (float)sommets;
    
        // for(int i = 0; i <= sommets; i++){
        //     for(int j = 0; j <= sommets; j++){
        //         float x = -m + j * pas;
        //         float z = -m + i * pas;
    
        //         plan.emplace_back(glm::vec3(x,0.0f,z));
    
        //         float u = (float)j / (float)(sommets-1);
        //         float v = (float)i / (float)(sommets-1);
    
        //         uvs.emplace_back(glm::vec2(u,v));
        //     }
        // }
    
        // for(int i = 0; i < sommets-1; i++){
        //     for(int j = 0; j < sommets-1; j++){
        //         int topleft = i * (sommets+1) + j;
        //         int topright = topleft + 1;
        //         int bottomleft = (i+1) * (sommets+1) + j;
        //         int bottomright = bottomleft + 1;
    
        //         indices_plan.push_back(topleft);
        //         indices_plan.push_back(bottomleft);
        //         indices_plan.push_back(topright);
    
        //         indices_plan.push_back(topright);
        //         indices_plan.push_back(bottomleft);
        //         indices_plan.push_back(bottomright);
        //     }
        // }
    }
    

{ // Buffers plan
    // GLuint vertexbuffer_plan,uvbuffer,elementbuffer_plan;

    // glGenBuffers(1,&vertexbuffer_plan);
    // glBindBuffer(GL_ARRAY_BUFFER,vertexbuffer_plan);
    // glBufferData(GL_ARRAY_BUFFER,plan.size() * sizeof(glm::vec3),&plan[0],GL_STATIC_DRAW);

    // glGenBuffers(1,&uvbuffer);
    // glBindBuffer(GL_ARRAY_BUFFER,uvbuffer);
    // glBufferData(GL_ARRAY_BUFFER,uvs.size() * sizeof(glm::vec2),&uvs[0],GL_STATIC_DRAW);

    // glGenBuffers(1,&elementbuffer_plan);
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,elementbuffer_plan);
    // glBufferData(GL_ELEMENT_ARRAY_BUFFER,indices_plan.size() * sizeof(unsigned short),&indices_plan[0],GL_STATIC_DRAW);
}

{// Mise à jour de la résolution
    // --------------------
    // if(scaleT){
    //     scaleTerrain(plan,uvs,indices_plan,vertexbuffer_plan,uvbuffer,elementbuffer_plan,sommets);
    //     scaleT = false;
    // }

    // Rotation mode orbital
    // --------------------
    // if(orbital){
    //     angle += rotation_speed * deltaTime ;
    // }
}

glm::mat4 ModelMatrix;
    // if(orbital){
    //     ModelMatrix = glm::rotate(glm::mat4(1.0f),angle,glm::vec3(0.0f,1.0f,0.0f));
    // }else{
    ModelMatrix = glm::mat4(1.0f);
    // }

// glEnableVertexAttribArray(0);
    // glBindBuffer(GL_ARRAY_BUFFER,vertexbuffer_plan);
    // glVertexAttribPointer(0,3,GL_FLOAT, GL_FALSE,0,(void*)0);

    // glEnableVertexAttribArray(1);
    // glBindBuffer(GL_ARRAY_BUFFER,uvbuffer);
    // glVertexAttribPointer(1,2,GL_FLOAT,GL_FALSE,0,(void*)0);

    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,elementbuffer_plan);
    // glDrawElements(GL_TRIANGLES,indices_plan.size(),GL_UNSIGNED_SHORT,(void*)0);

    // glDisableVertexAttribArray(0);
    // glDisableVertexAttribArray(1);


// if(!orbital){
// }else{
    //     camera_position = orbital_camera_position;
    //     camera_target = glm::normalize(camera_target - orbital_camera_position);
    // }

    /****************************************/
    // Augmenter ou diminuer la résolution du plan

    // if(glfwGetKey(window, GLFW_KEY_U) == GLFW_PRESS && sommets <= MAX_SOMMETS){
    //     sommets += 2;
    //     scaleT = true;
    // }
    // if(glfwGetKey(window, GLFW_KEY_J) == GLFW_PRESS && sommets > MIN_SOMMETS){
    //     sommets -= 2;
    //     scaleT = true;
    // }

    /****************************************/
    // Angle de perspective

    // if(glfwGetKey(window, GLFW_KEY_B) == GLFW_PRESS)
    //     angle_perspective += 1.0f;
    // if(glfwGetKey(window, GLFW_KEY_N) == GLFW_PRESS)
    //     angle_perspective -= 1.0f;

    /****************************************/
    // Vitesse de rotation (mode orbital)

    // if(glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
    //     rotation_speed += 0.1f;
    // if(glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
    //     rotation_speed -= 0.1f;

    /****************************************/
    // Position de la caméra selon le mode (manuel ou orbital)

    // if(glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS){
    //     orbital = !orbital;
    //     if(orbital){
    //         camera_position = orbital_camera_position;
    //         camera_target = glm::normalize(camera_target - orbital_camera_position);
    //     }
    //     if(!orbital){
    //         camera_position   = glm::vec3(0.0f,1.0f,7.0f);
    //         camera_target = glm::vec3(0.0f,0.0f,-1.0f);
    //     }
    // }

void scaleTerrain(std::vector<glm::vec3> &plan,std::vector<glm::vec2> &uvs,std::vector<unsigned short> &indices_plan,GLuint &vertexbuffer_plan,GLuint &uvbuffer,GLuint &elementbuffer_plan, int sommets) {
    plan.clear();
    uvs.clear();
    indices_plan.clear();

    float taille = 10.0f;
    float m = taille / 2.0f;
    float pas = taille / (float)sommets;

    for (int i = 0; i <= sommets; i++) {
        for (int j = 0; j <= sommets; j++) {
            float x = -m + j * pas;
            float z = -m + i * pas;
            plan.emplace_back(glm::vec3(x,0.0f, z));

            float u = (float)j / (float)(sommets - 1);
            float v = (float)i / (float)(sommets - 1);
            uvs.emplace_back(glm::vec2(u, v));
        }
    }

    for (int i = 0; i < sommets-1; i++) {
        for (int j = 0; j < sommets-1; j++) {
            int topleft = i * (sommets + 1) + j;
            int topright = topleft + 1;
            int bottomleft = (i + 1) * (sommets + 1) + j;
            int bottomright = bottomleft + 1;

            indices_plan.push_back(topleft);
            indices_plan.push_back(bottomleft);
            indices_plan.push_back(topright);

            indices_plan.push_back(topright);
            indices_plan.push_back(bottomleft);
            indices_plan.push_back(bottomright);
        }
    }

    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer_plan);
    glBufferData(GL_ARRAY_BUFFER, plan.size() * sizeof(glm::vec3), &plan[0], GL_STATIC_DRAW);

    glBindBuffer(GL_ARRAY_BUFFER, uvbuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &uvs[0], GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementbuffer_plan);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices_plan.size() * sizeof(unsigned short), &indices_plan[0] , GL_STATIC_DRAW);
}